<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>最新版ElasticSearch免费加密</title>
      <link href="/2019/05/08/da-shu-ju/zui-xin-ban-elasticsearch-mian-fei-jia-mi/"/>
      <url>/2019/05/08/da-shu-ju/zui-xin-ban-elasticsearch-mian-fei-jia-mi/</url>
      
        <content type="html"><![CDATA[<h3 id="Search-Guard官方地址"><a href="#Search-Guard官方地址" class="headerlink" title="Search Guard官方地址"></a><a href="https://search-guard.com/" target="_blank" rel="noopener">Search Guard官方地址</a></h3><pre class=" language-javascript"><code class="language-javascript">    <span class="token number">1</span><span class="token punctuation">.</span> 下载Es插件：<span class="token punctuation">.</span><span class="token operator">/</span>bin<span class="token operator">/</span>elasticsearch<span class="token operator">-</span>plugin install <span class="token operator">-</span>b search<span class="token operator">-</span>guard版本号    <span class="token number">2</span><span class="token punctuation">.</span>  bash <span class="token operator">/</span>plugins<span class="token operator">/</span>search<span class="token operator">-</span>guard<span class="token number">-7</span><span class="token operator">/</span>tools<span class="token operator">/</span>install_demo_configuration<span class="token punctuation">.</span>sh    <span class="token number">3</span><span class="token punctuation">.</span> <span class="token function">一直输入y</span><span class="token punctuation">(</span>最后一个选项是是否集群模式<span class="token punctuation">,</span>可以选择输入n<span class="token punctuation">)</span>    <span class="token number">4</span><span class="token punctuation">.</span> 启动Es并打开：https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token punctuation">:</span><span class="token number">9200</span><span class="token operator">/</span>_searchguard<span class="token operator">/</span>authinfo    <span class="token number">5</span><span class="token punctuation">.</span> 全部同意<span class="token punctuation">,</span>然后输入账号：admin  密码：admin    <span class="token number">6</span><span class="token punctuation">.</span> bash <span class="token operator">/</span>plugins<span class="token operator">/</span>search<span class="token operator">-</span>guard<span class="token number">-7</span><span class="token operator">/</span>tools<span class="token operator">/</span>hash<span class="token punctuation">.</span>sh <span class="token operator">-</span>p 新的密码  <span class="token punctuation">(</span>返回一个加密过的数据<span class="token punctuation">)</span>    <span class="token number">7</span><span class="token punctuation">.</span> 打开 <span class="token operator">/</span>plugins<span class="token operator">/</span>search<span class="token operator">-</span>guard<span class="token number">-7</span><span class="token operator">/</span>sgconfig<span class="token operator">/</span>sg_internal_users<span class="token punctuation">.</span>yml    <span class="token number">8</span><span class="token punctuation">.</span> 找到admin对应hash字段的值并将第六步生产的密码替换    <span class="token number">9</span><span class="token punctuation">.</span> bash <span class="token operator">/</span>plugins<span class="token operator">/</span>search<span class="token operator">-</span>guard<span class="token number">-7</span><span class="token operator">/</span>tools<span class="token operator">/</span>sgadmin_demo<span class="token punctuation">.</span>sh    <span class="token number">10</span><span class="token punctuation">.</span> 重启ES测试密码是否正确</code></pre><ul><li><a href="https://docs.search-guard.com/latest/search-guard-versions" target="_blank" rel="noopener">Es插件版本号查询</a></li></ul><pre class=" language-javascript"><code class="language-javascript">    <span class="token number">1</span><span class="token punctuation">.</span> 下载Kibana插件：<span class="token punctuation">.</span><span class="token operator">/</span>bin<span class="token operator">/</span>kibana<span class="token operator">-</span>plugin install kibana插件地址    <span class="token number">2</span><span class="token punctuation">.</span> 修改config中kibana<span class="token punctuation">.</span>yml添加以下数据    # Use HTTPS instead <span class="token keyword">of</span> HTTP    elasticsearch<span class="token punctuation">.</span>hosts<span class="token punctuation">:</span> <span class="token string">"https://localhost:9200"</span>    # Configure the Kibana internal server user    elasticsearch<span class="token punctuation">.</span>username<span class="token punctuation">:</span> <span class="token string">"kibanaserver"</span>    elasticsearch<span class="token punctuation">.</span>password<span class="token punctuation">:</span> <span class="token string">"kibanaserver"</span>    # Disable SSL verification because we use self<span class="token operator">-</span>signed demo certificates    elasticsearch<span class="token punctuation">.</span>ssl<span class="token punctuation">.</span>verificationMode<span class="token punctuation">:</span> none    # Whitelist the Search Guard Multi Tenancy Header    elasticsearch<span class="token punctuation">.</span>requestHeadersWhitelist<span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"Authorization"</span><span class="token punctuation">,</span> <span class="token string">"sgtenant"</span> <span class="token punctuation">]</span>    # 禁止xpack    xpack<span class="token punctuation">.</span>monitoring<span class="token punctuation">.</span>enabled<span class="token punctuation">:</span> <span class="token boolean">false</span>    xpack<span class="token punctuation">.</span>graph<span class="token punctuation">.</span>enabled<span class="token punctuation">:</span> <span class="token boolean">false</span>    xpack<span class="token punctuation">.</span>ml<span class="token punctuation">.</span>enabled<span class="token punctuation">:</span> <span class="token boolean">false</span>    xpack<span class="token punctuation">.</span>watcher<span class="token punctuation">.</span>enabled<span class="token punctuation">:</span> <span class="token boolean">false</span>    xpack<span class="token punctuation">.</span>security<span class="token punctuation">.</span>enabled<span class="token punctuation">:</span> <span class="token boolean">false</span>    <span class="token number">3</span><span class="token punctuation">.</span> <span class="token function">启动kibana查看是否需要输入账号密码</span><span class="token punctuation">(</span>Es的账号密码即可<span class="token punctuation">)</span></code></pre><ul><li><a href="https://search.maven.org/search?q=a:search-guard-kibana-plugin" target="_blank" rel="noopener">Kibana插件版本号查询</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> ElasticSearch </tag>
            
            <tag> Search-Guard </tag>
            
            <tag> Kibana </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidStudio常用快捷键</title>
      <link href="/2016/09/27/android/androidstudio/"/>
      <url>/2016/09/27/android/androidstudio/</url>
      
        <content type="html"><![CDATA[<h3 id="常用的-Android-Studio-快捷键"><a href="#常用的-Android-Studio-快捷键" class="headerlink" title="常用的 Android Studio 快捷键:"></a>常用的 Android Studio 快捷键:</h3><p>以下是平时在Windwos系统上用Android Studio进行开发时常用到的一些快捷键，虽然不多，但是感觉都还蛮实用的，因此记录下来，如果什么时候不小心忘记了可以拿来翻一翻，That would be very useful！</p><blockquote><p>　　1.Ctrl + B</p></blockquote><p>　　跳入/跳出方法或者资源文件。将鼠标光标定位到某个方法或者资源id的调用处，按Ctrl + B，将会跳入该方法或者资源文件内部，功能等同于Ctrl + 鼠标左键。如果将鼠标光标定位到方法定义处或者资源文件内部，按Ctrl + B将会返回调用处。</p><blockquote><p>　　2.Ctrl + O</p></blockquote><p>　　查看父类中的方法， 并可以选择父类方法进行覆盖。将鼠标光标定位到类中代码的任意位置，按Ctrl + O，将会在打开的面板中查看到所有父类中的所有非私有方法，选择某个方法按Enter即可覆盖父类方法。</p><blockquote><p>　　3.Ctrl + K</p></blockquote><p>　　SVN提交代码。</p><blockquote><p>　　4.Ctrl + T</p></blockquote><p>　　SVN更新代码。</p><blockquote><p>　　5.Ctrl + H</p></blockquote><p>　　查看类的上下继承关系。将鼠标光标定位在类中的任何一个位置，然后按Ctrl + H，将会打开一个面板，在这个面板中会依照层级显示出当前类的所有父类和子类。</p><blockquote><p>　　6.Ctrl + W</p></blockquote><p>　　选中代码块。多次按Ctrl + W将逐步扩大选择范围。</p><blockquote><p>　　7.Ctrl + E</p></blockquote><p>　　显示最近打开的文件，可以快速再次打开这些文件。</p><blockquote><p>　　8.Ctrl + U</p></blockquote><p>　　快速跳转至父类，或者快速跳转到父类中的某个方法。将鼠标光标定位到类名上，按Ctrl +U，将会打开当前类的父类，如果当前类有多个父类，则会提示要打开的父类。如果一个类中的方法覆盖了其父类的方法，那么将鼠标光标定位到子类的方法，按Ctrl + U，将</p><p>会跳转到被覆盖的父类方法中。</p><blockquote><p>　　9.Ctrl + G</p></blockquote><p>　　显示鼠标光标当前位置在代码文件中的行/列数。可以理解为光标在代码中的横纵坐标。</p><blockquote><p>　　10.Ctrl + F12</p></blockquote><p>　　查看类中的所有变量、方法、内部类、内部接口。将鼠标光标定位到当前类文件的任意位置，按Ctrl + F12会弹出显示类中所有变量、方法、内部类、内部接口的对话框，然后按↑↓键可以选择某个变量、方法、内部类、内部接口，接着按Enter可以快速定位到该变</p><p>量、方法、内部类、内部接口。</p><blockquote><p>　　11.Ctrl + F11</p></blockquote><p>　　添加书签。在鼠标光标位置所在行添加书签。如果文件中的代码特别多，那么书签将是一个非常实用的功能，它可以帮助我们标记代码中的重要位置，方便我们下次快速定位到这些重要位置。</p><blockquote><p>　　12.Shift + F11</p></blockquote><p>　　查看书签。可以快速查看之前标记的书签。</p><blockquote><p>　　13.Ctrl + Shift + F12</p></blockquote><p>　　快速调整代码编辑窗口的大小。</p><blockquote><p>　　14.Ctrl + ↑↓</p></blockquote><p>　　固定光标上下移动代码。</p><blockquote><p>　　15.Alt + ↑↓</p></blockquote><p>　　在内部接口、内部类和方法之间跳转。</p><blockquote><p>　　16.Ctrl + Shift + Backspace</p></blockquote><p>　　回到上一次编辑的位置。</p><blockquote><p>　　17.Alt + 数字</p></blockquote><p>　　打开相应数字的面板。如终端控制台面板对应的数字是6，那么按Alt + 6可以快速展开或关闭控制台面板。</p><blockquote><p>　　18.Ctrl + Shift + I</p></blockquote><p>　　快速查看某个方法、类、接口的内容。将鼠标光标定位到某个方法、类名、接口名，然后按Ctrl + Shift + I，将会在当前光标位置显示改方法、类、接口的内容。</p><blockquote><p>　　19.Shift + Esc</p></blockquote><p>　　关闭当前打开的面板。</p><blockquote><p>　　20.Alt + J</p></blockquote><p>　　选择多个相同名字的关键字、方法、类、接口，然后同时更改。</p><blockquote><p>　　21.Ctrl + Tab</p></blockquote><p>　　切换面板或文件，功能类似Windows下的Alt + Tab。在切换面板/文件的对话框中，选中某个面板或文件，接着按Backspace即可关闭改面板或文件。</p><blockquote><p>　　22.trl + Shift + Enter</p></blockquote><p>　　快速补全语句。如if() {}、switch(){}代码块，只要输入if或者switch（甚至sw），接着按Ctrl + Shift + Enter可以快速完形代码块。</p><blockquote><p>　　23.Ctrl + Alt + M</p></blockquote><p>　　快速抽取方法。选中代码块，然后按Ctrl + Alt + M可以快速将选中的代码块抽取为一个方法。</p><blockquote><p>　　24.Ctrl + Alt + T </p></blockquote><p>　　快速包裹代码块。选中一段代码，然后按Ctrl + Alt + T，可以选择要对选中代码块进行的操作，如：if / else、do / while、try / catch / finally等。</p><blockquote><p>　　25.Ctrl  + Alt + L</p></blockquote><p>　　代码格式化。</p><blockquote><p>　　26.Ctrl + N</p></blockquote><p>　　快速查找类。按下Ctrl + N会弹出输入类名的对话框，在对话框的搜索框中输入要查找的类名，即可开始进行模糊检索，这样可以快速找到需要查找的类，这在类文件非常多的工程里面特别实用。</p><blockquote><p>　　27.Ctrl + Shift + N</p></blockquote><p>　　快速查找文件。功能和Ctrl + N类似，但是除了可以搜索类文件之外，还可以搜索当前工程下的所有文件，这同样是一个经常用到的特别实用的功能。</p><blockquote><p>　　28.Double Shift</p></blockquote><p>　　全局搜索。功能和Ctrl + N、Ctrl + Shift + N类似，但是搜索的范围更广，支持符号检索，除了Ctrl + N、Ctrl + Shift + N的检索内容外，还可以搜索到变量、资源id等。</p><blockquote><p>　　29.Ctrl + Alt + Space</p></blockquote><p>　　类名或接口名提示。输入一个不完整的类名或者接口名，按Ctrl + Alt + Space，会给出完整类名或接口名的提示。</p><blockquote><p>　　30.Ctrl  + Q</p></blockquote><p>　　显示注释文档。将鼠标光标定位到某个类名、接口名或者方法名，按Ctrl + Q，会显示出该类、接口、方法的注释。</p><blockquote><p>　　31.Ctrl + PageUp/PageDown</p></blockquote><p>　　将光标定位到当前文件的第一行/最后一行。</p><blockquote><p>　　32.Shift + Left Click（当前文件的选项卡）</p></blockquote><p>　　关闭当前文件。</p><blockquote><p>　　33.Ctrl + Alt + B　　</p></blockquote><p>　　跳转到抽象方法的实现。将鼠标光标定位到某个抽象方法，然后按Ctrl + Alt + B，会快速跳转到该抽象方法的具体实现处，如果该抽象方法有多个具体实现，那么会弹出选择框进行选择。</p><blockquote><p>　　34.Ctrl + Shift + U </p></blockquote><p>　　快速进行大小写转换。</p><blockquote><p>　　35.Ctrl + Shift + Alt + S</p></blockquote><p>　　打开Project Structure面板。</p><blockquote><p>　　36.Ctrl + F</p></blockquote><p>　　在当前文件中搜索输入的内容。</p><blockquote><p>　　37.Ctrl + R</p></blockquote><p>　　在当前文件中替换输入的内容。</p><blockquote><p>　　38.Ctrl + Shift + F</p></blockquote><p>　　全局搜索。</p><blockquote><p>　　39.Ctrl + Shift + R</p></blockquote><p>　　全局替换。</p><blockquote><p>　　40.Shift + F6</p></blockquote><p>　　快速重命名。选中某个类、变量、资源id等之后，可以快速重命名，只要改动一个位置，其它地方也都会自动全部重命名。</p><blockquote><p>　　41.Alt + F7</p></blockquote><p>　　快速查找某个类、方法、变量、资源id被调用的地方。</p><blockquote><p>　　42.Ctrl +Shift + Alt + I</p></blockquote><p>　　对项目进行审查。按下Ctrl +Shift + Alt + I，会弹出搜索审查项的输入框，输入关键字可以检索需要审查的内容，例如输入unused resource即可搜索项目中没有使用到的资源文件。此外，在菜单栏选择Analyze—Inspect Code或者鼠标右键点击当前工程— 　Analyze—Inspect Code，可以对项目进行Lint审查。</p><blockquote><p>　　43.Ctrl + D</p></blockquote><p>　　快速复制行。</p><blockquote><p>　　44.Ctrl + Shift + ↑↓</p></blockquote><p>　　上下移动代码。如果是方法中的代码，只能在方法内部一定，不能跨方法。</p><blockquote><p>　　45.Shift + Alt + ↑↓</p></blockquote><p>　　上下移动代码。可以跨方法移动。</p><blockquote><p>　　46.Shift + F10</p></blockquote><p>　　启动Module。</p><blockquote><p>　　47.Shift + F9</p></blockquote><p>　　调试Module。</p><blockquote><p>　　48.Ctrl + F9</p></blockquote><p>　　Make Project。</p><blockquote><p>　　49.Alt + Insert</p></blockquote><p>　　快速插入代码。可以快速生成构造方法、Getter/Setter方法等。</p><blockquote><p>　　50.Alt + Enter</p></blockquote><p>　　快速修复错误。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Activity生命周期</title>
      <link href="/2016/09/27/android/activity/"/>
      <url>/2016/09/27/android/activity/</url>
      
        <content type="html"><![CDATA[<p>Activity恐怕是Android用得最多且是最基本的组件了，估计也是每个学Android的人接触的第一概念，Activity的生命周期与启动模式是作为一个Android开发程序员必要掌握内容 ， 还希望本篇文章对您有所帮助。</p><h3 id="Activity的形态"><a href="#Activity的形态" class="headerlink" title="Activity的形态"></a>Activity的形态</h3><p> <strong>Active/Running:</strong> Activity处于活动状态，此时Activity处于栈顶，是可见状态，可与用户进行交互。 </p><p><strong>Paused：</strong> 当Activity失去焦点时，或被一个新的非全屏的Activity，或被一个透明的Activity放置在栈顶时，Activity就转化为Paused状态。但我们需要明白，此时Activity只是失去了与用户交互的能力，其所有的状态信息及其成员变量都还存在，只有在系统内存紧张的情况下，才有可能被系统回收掉。 </p><p><strong>Stopped： </strong>当一个Activity被另一个Activity完全覆盖时，被覆盖的Activity就会进入Stopped状态，此时它不再可见，但是跟Paused状态一样保持着其所有状态信息及其成员变量。 </p><p><strong>Killed： </strong>当Activity被系统回收掉时，Activity就处于Killed状态。 </p><h3 id="Activity-的生命周期"><a href="#Activity-的生命周期" class="headerlink" title="Activity 的生命周期"></a>Activity 的生命周期</h3><p>Activity 类中定义了七回调方法，覆盖了活动生命周期的每一个环节，从启动到销毁的过程中只有当我们熟练的掌握了它的生命周期才能在它的回调方法中做合适的事情,先为大家献上一张生命周期图，供大家参考<br>  <img src="http://pic001.cnblogs.com/img/tea9/201008/2010080516521645.png" alt></p><p><strong>onCreate:</strong> 该方法是我们见到最多的回调方法,是在Activity被创建时回调，它是生命周期第一个调用的方法，我们在创建Activity时一般都需要重写该方法，然后在该方法中做一些初始化的操作，如通过setContentView设置界面布局的资源，初始化所需要的组件信息等。 </p><p><strong>onStart:</strong> 此方法被回调时表示Activity正在启动，此时Activity已处于可见状态，只是还没有在前台显示，因此无法与用户进行交互。可以简单理解为Activity已显示而我们无法看见摆了。<br>onResume : 当此方法回调时，则说明Activity已在前台可见，可与用户交互了（处于前面所说的Active/Running形态），onResume方法与onStart的相同点是两者都表示Activity可见，只不过onStart回调时Activity还是后台无法与用户交互，而onResume则已显示在前台，可与用户交互。当然从流程图，我们也可以看出当Activity停止后（onPause方法和onStop方法被调用），重新回到前台时也会调用onResume方法，因此我们也可以在onResume方法中初始化一些资源，比如重新初始化在onPause或者onStop方法中释放的资源。</p><p><strong>onPause:</strong> 此方法被回调时则表示Activity正在停止（Paused形态），一般情况下onStop方法会紧接着被回调。但通过流程图我们还可以看到一种情况是onPause方法执行后直接执行了onResume方法，这属于比较极端的现象了，这可能是用户操作使当前Activity退居后台后又迅速地再回到到当前的Activity，此时onResume方法就会被回调。当然，在onPause方法中我们可以做一些数据存储或者动画停止或者资源回收的操作，但是不能太耗时，因为这可能会影响到新的Activity的显示——onPause方法执行完成后，新Activity的onResume方法才会被执行。</p><p><strong>onStop:</strong>  一般在onPause方法执行完成直接执行，表示Activity即将停止或者完全被覆盖（Stopped形态），此时Activity不可见，仅在后台运行。同样地，在onStop方法可以做一些资源释放的操作（不能太耗时）。 </p><p><strong>onRestart:</strong> 表示Activity正在重新启动，当Activity由不可见变为可见状态时，该方法被回调。这种情况一般是用户打开了一个新的Activity时，当前的Activity就会被暂停（onPause和onStop被执行了），接着又回到当前Activity页面时，onRestart方法就会被回调。<br>onDestroy :此时Activity正在被销毁，也是生命周期最后一个执行的方法，一般我们可以在此方法中做一些回收工作和最终的资源释放。 </p><h3 id="Activity的四种启动模式"><a href="#Activity的四种启动模式" class="headerlink" title="Activity的四种启动模式"></a>Activity的四种启动模式</h3><ol><li><p>Standard模式（默认）</p><p> 我们平时直接创建的Activity都是这种模式的Activity，这种模式的Activity的特点是：只要你创建了Activity实例，一旦激活该Activity，则会向任务栈中加入新创建的实例，退出Activity则会在任务栈中销毁该实例。</p></li></ol><ol start="2"><li><p>SingleTop模式</p><p> 这种模式会考虑当前要激活的Activity实例在任务栈中是否正处于栈顶，如果处于栈顶则无需重新创建新的实例，会重用已存在的实例，否则会在任务栈中创建新的实例。</p></li></ol><ol start="3"><li><p>SingleTask模式</p><p>如果任务栈中存在该模式的Activity实例，则把栈中该实例以上的Activity实例全部移除，调用该实例的newInstance()方法重用该Activity，使该实例处於栈顶位置，否则就重新创建一个新的Activity实例。</p></li></ol><ol start="4"><li><p>SingleInstance模式</p><p>SingleInstance启动模式非常特殊,Activity会运行在自己的任务栈中,并且这个任务栈中只有一个实例存在,如果你想保证手机系统中只有一个实例存在那么可以使用这种启动方式<br>应用场景：手机来电</p></li></ol><h3 id="如何更改Activity的启动模式"><a href="#如何更改Activity的启动模式" class="headerlink" title="如何更改Activity的启动模式:"></a>如何更改Activity的启动模式:</h3><pre><code>   打开AndroidManifest.xml配置文件,    找到对应的Activity  配置 android:launchMode=&quot;&quot; 更改自己所要更改的启动模式即可</code></pre><p><img src="http://img.blog.csdn.net/20180402102141784?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhb2h1YW5nbml1MTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="如何更改Activity的启动模式"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 设计模式 -   工厂模式</title>
      <link href="/2016/09/27/java/java-gong-han-she-ji-mo-shi/"/>
      <url>/2016/09/27/java/java-gong-han-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="JAVA设计模式-工厂模式"><a href="#JAVA设计模式-工厂模式" class="headerlink" title="JAVA设计模式 - 工厂模式"></a>JAVA设计模式 - 工厂模式</h3><hr><p>简单工厂的定义：提供一个创建对象实例的功能，而无须关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类</p><h3 id="实现汽车接口"><a href="#实现汽车接口" class="headerlink" title="实现汽车接口"></a>实现汽车接口</h3><pre><code>public interface Car {    String getName();&lt;strong&gt;}&lt;/strong&gt;</code></pre><h3 id="奔驰类"><a href="#奔驰类" class="headerlink" title="奔驰类"></a>奔驰类</h3><pre><code>public class Benz implements Car {    @Override    public String getName() {        return &quot;Benz&quot;;    }}</code></pre><h3 id="宝马类"><a href="#宝马类" class="headerlink" title="宝马类"></a>宝马类</h3><pre><code>public class BMW implements Car {    @Override    public String getName() {        return &quot;BMW&quot;;    }}</code></pre><h3 id="简单工厂，既能生产宝马又能生产奔驰"><a href="#简单工厂，既能生产宝马又能生产奔驰" class="headerlink" title="简单工厂，既能生产宝马又能生产奔驰"></a>简单工厂，既能生产宝马又能生产奔驰</h3><pre><code>public class SimpleFactory {    public Car getCar(String name){        if (name.equals(&quot;BMW&quot;)){            return new BMW();        }else if (name.equals(&quot;benz&quot;)){            return new Benz();        }else {            System.out.println(&quot;不好意思，这个品牌的汽车生产不了&quot;);            return null;        }    }}</code></pre><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><pre><code>public class SimpleFactoryTest {    public static void main(String[] args){        SimpleFactory simpleFactory = new SimpleFactory();        Car car = simpleFactory.getCar(&quot;BMW&quot;);        System.out.println(car.getName());    }}</code></pre><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><pre><code>BMW</code></pre><hr><p>根据简单工厂的定义，用户只要产品而不在乎产品如何生产，看起来好像很完美的样子。但大家想想，这个世界存在什么都生产的工厂吗？</p><p>显然是不存在的，每一个汽车品牌都有自己的生产工厂，都有自己生产技术。映射到spring框架中，我们有很多很多种的bean需要生产，如果只依靠一个简单工厂来实现，那么我们得在工厂类中嵌套多少个if..else if啊？</p><p>而且我们在代码中生产一辆汽车只是new一下就出来了，但实际操作中却不知道需要进行多少操作，加载、注册等操作都将体现在工厂类中，那么这个类就会变得紊乱，管理起来也很不方便，所以说每个品牌应该有自己的生产类。</p><p>因为专一，所以专业嘛，这个时候工厂方法就出现了。</p><h3 id="二、工厂方法"><a href="#二、工厂方法" class="headerlink" title="二、工厂方法"></a>二、工厂方法</h3><h3 id="工厂接口"><a href="#工厂接口" class="headerlink" title="工厂接口"></a>工厂接口</h3><pre><code>//定义一个工厂接口，功能就是生产汽车public interface Factory {    Car getCar();}</code></pre><h3 id="奔驰工厂"><a href="#奔驰工厂" class="headerlink" title="奔驰工厂"></a>奔驰工厂</h3><pre><code>public class BenzFactory implements Factory {    @Override    public Car getCar() {        return new Benz();    }}</code></pre><h3 id="宝马工厂"><a href="#宝马工厂" class="headerlink" title="宝马工厂"></a>宝马工厂</h3><pre><code>public class BMWFactory implements Factory{    @Override    public Car getCar() {        return new BMW();    }}</code></pre><h3 id="测试类-1"><a href="#测试类-1" class="headerlink" title="测试类"></a>测试类</h3><pre><code>public class FactoryTest {   public static void main(String[] args){       Factory bmwFactory = new BMWFactory();       System.out.println(bmwFactory.getCar().getName());       Factory benzFactory = new BenzFactory();       System.out.println(benzFactory.getCar().getName());   }}</code></pre><h3 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h3><pre><code>BMWBenz</code></pre><hr><p>根据上述代码可以看出，不同品牌的汽车是由不同的工厂生产的，貌似又是很完美的。但大家看一下测试类，当一个人想要去买一辆宝马汽车的时候（假设没有销售商），那么他就要去找宝马工厂给他生产一辆，过几天又想要买一辆奔驰汽车的时候，又得跑到奔驰工厂请人生产，这无疑就增加了用户的操作复杂性。所以有没有一种方便用户操作的方法呢？这个时候抽象工厂模式就出现了。</p><h3 id="三、抽象工厂"><a href="#三、抽象工厂" class="headerlink" title="三、抽象工厂"></a>三、抽象工厂</h3><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><pre><code>public abstract class AbstractFactory {     protected abstract Car getCar();     //这段代码就是动态配置的功能     //固定模式的委派     public Car getCar(String name){        if(&quot;BMW&quot;.equalsIgnoreCase(name)){            return new BmwFactory().getCar();        }else if(&quot;Benz&quot;.equalsIgnoreCase(name)){            return new BenzFactory().getCar();        }else if(&quot;Audi&quot;.equalsIgnoreCase(name)){            return new AudiFactory().getCar();        }else{            System.out.println(&quot;这个产品产不出来&quot;);            return null;        }    }}</code></pre><h3 id="默认工厂"><a href="#默认工厂" class="headerlink" title="默认工厂"></a>默认工厂</h3><pre><code>public class DefaultFactory extends AbstractFactory {    private AudiFactory defaultFactory = new AudiFactory();    public Car getCar() {        return defaultFactory.getCar();    }}</code></pre><h3 id="宝马工厂-1"><a href="#宝马工厂-1" class="headerlink" title="宝马工厂"></a>宝马工厂</h3><pre><code>public class BMWFactory extends AbstractFactory {    @Override    public Car getCar() {        return new BMW();    }}</code></pre><h3 id="奔驰工厂-1"><a href="#奔驰工厂-1" class="headerlink" title="奔驰工厂"></a>奔驰工厂</h3><pre><code>public class BenzFactory extends AbstractFactory {    @Override    public Car getCar() {        return new Benz();    }}</code></pre><h3 id="测试类-2"><a href="#测试类-2" class="headerlink" title="测试类"></a>测试类</h3><pre><code>public class AbstractFactoryTest {    public static void main(String[] args) {                DefaultFactory factory = new DefaultFactory();  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在此我向大家推荐一个架构学习交流圈：830478757        System.out.println(factory.getCar(&quot;Benz&quot;).getName());                }}</code></pre><h3 id="测试结果-2"><a href="#测试结果-2" class="headerlink" title="测试结果"></a>测试结果</h3><pre><code>Benz</code></pre><hr><p>根据上述代码可以看出，用户需要一辆汽车，只需要去找默认的工厂提出自己的需求（传入参数），便能得到自己想要产品，而不用根据产品去寻找不同的生产工厂，方便用户操作。</p><p>按我粗浅的理解，设计模式的经典之处，就在于解决了编写代码的人和调用代码的人双方的痛楚，不同的设计模式也只适用于不同的场景。至于用或者不用，如何使用，那就需要各位看官着重考虑了。</p><p>但为了使用而使用是不应该的，细微之处，只有留给大家慢慢品味了。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 设计模式 -   单例模式</title>
      <link href="/2016/09/26/java/java-dan-li-she-ji-mo-shi/"/>
      <url>/2016/09/26/java/java-dan-li-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="JAVA设计模式-单例模式"><a href="#JAVA设计模式-单例模式" class="headerlink" title="JAVA设计模式 - 单例模式"></a>JAVA设计模式 - 单例模式</h3><hr><p>  单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>  这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><h3 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h3><pre><code>public class Singleton{    //内部创建静态对象    private static Singleton instance=new Singleton();    //私有化构造函数    private Singleton(){}    //静态方法返回实例    pulic static Singleton getInstance(){        return instance;    }  }</code></pre><blockquote><p>特点：饿汉式会提前进行实例化，没有延迟加载，不管是否使用都会有一个已经初始化的实例在内存中，但不会出现懒汉式中的多线程问题。</p></blockquote><h3 id="懒汉式单例模式"><a href="#懒汉式单例模式" class="headerlink" title="懒汉式单例模式"></a>懒汉式单例模式</h3><pre><code>  public class Singleton{    private static Singleton instance;    private Singleton(){}    public static Singleton getInstance(){        //此处为空的判断如果不加线程锁,会出现线程安全问题        if(instance==null)            return instance=new Singleton();        else            return instance;    }  }</code></pre><blockquote><p>特点：实现了延迟加载，但在多线程情况下可能会出现问题，不能保证线程安全。</p></blockquote><h3 id="确保线程安全的懒汉式单例模式"><a href="#确保线程安全的懒汉式单例模式" class="headerlink" title="确保线程安全的懒汉式单例模式"></a>确保线程安全的懒汉式单例模式</h3><pre><code>  public class Singleton{    private static Singleton instance;    private Singleton(){}    public static sychronized Singleton getInstance(){        if(instance==null)            return instance=new Singleton();        else            return instance;    }  }</code></pre><blockquote><p>特点：synchronized限制了整个getInstance方法的完成执行</p></blockquote><h3 id="静态内部类的单例模式"><a href="#静态内部类的单例模式" class="headerlink" title="静态内部类的单例模式"></a>静态内部类的单例模式</h3><pre><code>  public class Singleton{    private Singleton(){}    private static class Inner{        private static Singleton instanceHolder=new Singleton();    }    public static Singleton getInstacen(){        return Inner.instanceHolder;    }  }</code></pre><blockquote><p>特点:由于内部类在编译完成后也是一个单独的class文件，因此在不使用的情况下Inner类是不会被加载的。同时，JVM保证在类加载的过程中static代码块在多线程或者单线程下都正确执行，且仅执行一次。解决了延迟加载以及线程安全的问题。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
